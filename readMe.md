# HuffmanCompression

Сжатие данных с помощью алгоритма Хафмана.

### Суть

Некие строковые данные можно сжать, т.к.
* Символы в строке повторяются (а каждый из них занимает 8-16 бит)
* Нет смысла тратить на каждый символ по 8 бит (ну, если говорить о 
буквенно-цифровых символах UTF-8), в абсолютном большинстве случаев можно 
обойтись меньшим (чем именно - зависит от количества уникальных символов в строке)
* Можно обойтись и еще меньшим кол-вом бит для символов, чем из предыдущего пункта, 
если использовать коды переменной длины

### Проблема

Чтобы получившиеся сжатые данные можно было однозначно расшифровать, нужно использовать 
для символов префиксные коды (т.е. такие, для всех из которых верно условие, что один 
код не является началом другого)

### Линк

[Вот тут](https://www.youtube.com/watch?v=OQrwOywESGg) Сергей Архипов очень хорошо объясняет
постановку задачи и проблематику (хотя в решении, приведенном в видео, есть косяк - мапа кодов там строится
неоптимально, т.к. пропущена дополнительная сортировка списка узлов дерева после создания родительского
узла и его вставки в список - п.3 про сжатие в описании алгоритма).

### Алгоритм Хаффмана

Алгоритм Хаффмана позволяет создать набор максимально коротких префиксных кодов для набора символов.

**Сжатие**

1. Для каждого символа исходной строки вычисляется вес (например, это может быть количество вхождений символа в строку)
и составляется мапа весов символов
2. Для каждой записи мапы весов строится узел дерева кодов, содержащий чам символ и его вес. Это - листья дерева кодов. 
Листья сортируются по убыванию веса. Таким образом листья, соответствущие самым часто встречающимся символам, 
оказываются в голове списка.
3. На основании отсортированного списка, полученного в п.2 строится дерево по следующему алгоритму:<br>
    * Берем 2 последних узла из списка(с наименьшим весом) и складываем их веса. Создаем новый узел с весом, 
   равным этой сумме и без информации о символе. 2 узла, на основе которых он создан, становятся его дочерними узлами
    * Удаляем из списка из п.2 эти 2 узла и добавляем в него полученный для них родительский узел
    * Сортируем список по весам, чтобы этот родительский узел занял свое место
    * Повторяем процедуру до тех пор, пока в списке не останется один узел. Это и будет верхушка дерева
4. Для каждого символа исходной строки формируем код следующим образом:<br>
Идем по узлам от верхушки дерева к нужному символу. Поворот налево дописывает к пути `0`, направо - `1`. Т.е для каждого
символа получается код вида `10011101`, причем для наиболее часто встречающихся символов коды будут самые короткие.
И да - эти коды получаются префиксными
5. При записи или отправке строки куда-либо заменяем каждый символ в строке его кодом и пишем в выходной поток 
соответствующий бит (`0` или `1`)

**Декомпрессия**

1. Для декомпрессии понадобится мапа весов символов из п.1 про сжатие (ее нужно сохранить/передать вместе со сжатой
строкой).
2. На основании мапы весов строится дерево кодов (п.3 про сжатие) и уже по нему идет расшифровка строки
следующим образом:<br>
3. Берется следующий символ (бит) зашифрованной (сжатой) строки (для начала декомпрессии - первый), превращается в
строку (`0` или `1`)
4. По строке, полученной в п.3, делается проход по дереву кодов от верхнего узла (`0` - поворот налево, `1` - направо).
Если в итоге получен символ - он записывается в декодированную строку и процесс повторяется, начиная с п.3.
5. Если в п.4 символ не найден, то из исходной строки берется следующий символ (бит) и дописывается к тому пути,
по которому шел проход по дереву, после чего повторяются действия, начиная с п.4, но уже для вновь полученного пути

### Реализация

В проекте описаны интерфейсы `DataCompressor`, `CodeTreeCreator` и `WeightMapCreator`, а также класс `CodeTreeNode`
и реализации указанных интерфейсов.<br>
* интерфейс `DataCompressor` служит для сжатия и декомпрессии данных
* интерфейс `CodeTreeCreator` служит для создания дерева кодов
* интерфейс `WeightMapCreator` служит для создания мапы весов
* класс `CodeTreeNode` описывает узел мапы весов

Все эти сложности - для того, чтобы можно было при желании реализовать сжатие-декомпрессию данных с помощью
других реализаций (например - другой алгоритм расчета весов символов или другой алгоритм создания мапы).